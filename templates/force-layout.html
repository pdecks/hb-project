<!DOCTYPE html>
<html>
<head>
    <title>Force Layout Example 1</title>
    <style>

        .node {
            fill: #ccc;
            stroke-width: 2px;
        }

        .link {
            stroke: #777;
            stroke-width: 2px;
        }

        text {
            fill: #000;
            font: 10px sans-serif;
            pointer-events: none;
        }

    </style>
</head>

<body>
<script src='http://d3js.org/d3.v3.min.js'></script>
<script>

    // Define the dimensions of the visualization. We're using
    // a size that's convenient for displaying the graphic on
    // http://jsDataV.is

    var width = 800;
    var height = 600;

    // Define the data for the example. In general, a force layout
    // requires two data arrays. The first array, here named `nodes`,
    // contains the object that are the focal point of the visualization.
    // The second array, called `links` below, identifies all the links
    // between the nodes. (The more mathematical term is "edges.")

    // For the simplest possible example we only define two nodes. As
    // far as D3 is concerned, nodes are arbitrary objects. Normally the
    // objects wouldn't be initialized with `x` and `y` properties like
    // we're doing below. When those properties are present, they tell
    // D3 where to place the nodes before the force layout starts its
    // magic. More typically, they're left out of the nodes and D3 picks
    // random locations for each node. We're defining them here so we can
    // get a consistent application of the layout which lets us see the
    // effects of different properties.

    // var nodes = [
    //     {name: 'Meggie'},
    //     {name: 'Cynthia'},
    //     {name: 'Joel'},
    //     {name: 'Katie'},
    //     {name: 'Kristen'},
    //     {name: 'Heather'},
    
    //     {name: 'Rachelle'},
    //     {name: 'Jo'},
    //     {name: 'Alena'},
    //     {name: 'Alexandra'},
    //     {name: 'Angela'},
    //     {name: 'Ariana'},
    //     {name: 'Dana'},
    //     {name: 'Emily'},
    //     {name: 'Judy'},
    //     {name: 'Julie'},
    //     {name: 'Kat'},
    //     {name: 'Keirra'},
    //     {name: 'Kristine'},
    //     {name: 'Leslie'},
    //     {name: 'Lindsay'},
    //     {name: 'Mish'},
    //     {name: 'Natalie'},
    //     {name: 'Nicole'},
    //     {name: 'Nuvi'},
    //     {name: 'Pam'},
    //     {name: 'Becca'},
    //     {name: 'Sadie'},
    //     {name: 'Sarah'},
    //     {name: 'Shabnam'},
    //     {name: 'Stella'},
    //     {name: 'Theresa'},
    //     {name: 'Tiffany'},
    //     {name: 'Vi'},
    //     {name: 'Viola'}
    // ];
    // TODO: use JSON to get node
    var nodes = [
        {name: 'Meggie', advisor: 'Meggie'}, // 0
        {name: 'Cynthia', advisor: 'Cynthia'}, // 1
        {name: 'Joel', advisor: 'Joel'}, // 2
        {name: 'Katie', advisor: 'Katie'},  // 3
        {name: 'Kristen', advisor: 'Kristen'}, // 4
        {name: 'Heather', advisor: 'Heather'}, // 5

        {name: 'Rachelle', advisor: 'Meggie'}, // 6
        {name: 'Jo', advisor: 'Joel'}, // 7
        {name: 'Alena', advisor: 'Cynthia'},  // 8
        {name: 'Alexandra', advisor: 'Heather'},  // 9
        {name: 'Angela', advisor: 'Meggie'},  // 10
        {name: 'Ariana', advisor: 'Katie'},
        {name: 'Dana', advisor: 'Heather'},
        {name: 'Emily', advisor: 'Meggie'},
        {name: 'Judy', advisor: 'Kristen'},
        {name: 'Julie', advisor: 'Heather'},
        {name: 'Kat', advisor: 'Cynthia'},
        {name: 'Keirra', advisor: 'Joel'},
        {name: 'Kristine', advisor: 'Kristen'},
        {name: 'Leslie', advisor: 'Kristen'},
        {name: 'Lindsay', advisor: 'Katie'},
        {name: 'Mish', advisor: 'Kristen'},
        {name: 'Natalie', advisor: 'Joel'},
        {name: 'Nicole', advisor: 'Cynthia'},
        {name: 'Nuvi', advisor: 'Heather'},
        {name: 'Pam', advisor: 'Kristen'},
        {name: 'Becca', advisor: 'Heather'},
        {name: 'Sadie', advisor: 'Joel'},
        {name: 'Sarah', advisor: 'Cynthia'},
        {name: 'Shabnam', advisor: 'Meggie'},
        {name: 'Stella', advisor: 'Meggie'},
        {name: 'Theresa', advisor: 'Katie'},
        {name: 'Tiffany', advisor: 'Katie'},
        {name: 'Vi', advisor: 'Katie'},
        {name: 'Viola', advisor: 'Cynthia'}
    ];

    // The `links` array contains objects with a `source` and a `target`
    // property. The values of those properties are the indices in
    // the `nodes` array of the two endpoints of the link.

    var links = [
       {source: 0, target: 10}, // Meggie to Angela
       {source: 0, target: 13},
       {source: 0, target: 30},
       {source: 0, target: 6},
       {source: 0, target: 29},
       {source: 2, target: 27},
       {source: 2, target: 7},
       {source: 2, target: 22},
       {source: 2, target: 17},
       {source: 1, target: 8},
       {source: 1, target: 16},
       {source: 1, target: 23},
       {source: 1, target: 34},
       {source: 1, target: 28},
       {source: 4, target: 14},
       {source: 4, target: 18},
       {source: 4, target: 21},
       {source: 4, target: 25},
       {source: 4, target: 19},
       {source: 5, target: 9},
       {source: 5, target: 12},
       {source: 5, target: 15},
       {source: 5, target: 24},
       {source: 5, target: 26},
       {source: 3, target: 11},
       {source: 3, target: 32},
       {source: 3, target: 31},
       {source: 3, target: 33},
       {source: 3, target: 20}
    ];

    // Here's were the code begins. We start off by creating an SVG
    // container to hold the visualization. We only need to specify
    // the dimensions for this container.

    var svg = d3.select('body').append('svg')
                .attr('width', width)
                .attr('height', height);

    // Now we create a force layout object and define its properties.
    // Those include the dimensions of the visualization and the arrays
    // of nodes and links.

    var force = d3.layout.force()
                  .size([width, height])
                  .nodes(nodes)
                  .links(links);

    // There's one more property of the layout we need to define,
    // its `linkDistance`. That's generally a configurable value and,
    // for a first example, we'd normally leave it at its default.
    // Unfortunately, the default value results in a visualization
    // that's not especially clear. This parameter defines the
    // distance (normally in pixels) that we'd like to have between
    // nodes that are connected. (It is, thus, the length we'd
    // like our links to have.)

    force.linkDistance(width / 2);

    // Next we'll add the nodes and links to the visualization.
    // Note that we're just sticking them into the SVG container
    // at this point. We start with the links. The order here is
    // important because we want the nodes to appear "on top of"
    // the links. SVG doesn't really have a convenient equivalent
    // to HTML's `z-index`; instead it relies on the order of the
    // elements in the markup. By adding the nodes _after_ the
    // links we ensure that nodes appear on top of links.

    // Links are pretty simple. They're just SVG lines, and
    // we're not even going to specify their coordinates. (We'll
    // let the force layout take care of that.) Without any
    // coordinates, the lines won't even be visible, but the
    // markup will be sitting inside the SVG container ready
    // and waiting for the force layout.

    var link = svg.selectAll('.link')
                  .data(links)
                  .enter().append('line')
                  .attr('class', 'link');

    // Now it's the nodes turn. Each node is drawn as a circle.

    var node = svg.selectAll('.node')
                  .data(nodes)
                  .enter().append('g')
                  .attr('class', 'node');

    var color = d3.scale.category20();

    node.append("circle")
        .attr("r", 15)
        .style("fill", function (d) { return color(d.advisor); });

    // add the text

    node.append("text").text(function (d) { return d.name; });

    // We're about to tell the force layout to start its
    // calculations. We do, however, want to know when those
    // calculations are complete, so before we kick things off
    // we'll define a function that we want the layout to call
    // once the calculations are done.

    force.on('end', function () {

        // When this function executes, the force layout
        // calculations have concluded. The layout will
        // have set various properties in our nodes and
        // links objects that we can use to position them
        // within the SVG container.

        // First let's reposition the nodes. As the force
        // layout runs it updates the `x` and `y` properties
        // that define where the node should be centered.
        // To move the node, we set the appropriate SVG
        // attributes to their new values. We also have to
        // give the node a non-zero radius so that it's visible
        // in the container.

        // node.attr('x', function(d) { return d.x; })
        //     .attr('y', function(d) { return d.y; });

        node.attr("transform", function (d) {
            return "translate(" + d.x + "," + d.y + ")";
        });

        // We also need to update positions of the links.
        // For those elements, the force layout sets the
        // `source` and `target` properties, specifying
        // `x` and `y` values in each case.

        link.attr('x1', function (d) { return d.source.x; })
            .attr('y1', function (d) { return d.source.y; })
            .attr('x2', function (d) { return d.target.x; })
            .attr('y2', function (d) { return d.target.y; });

    });

    // Okay, everything is set up now so it's time to turn
    // things over to the force layout. Here we go.

    force.start();

    // By the time you've read this far in the code, the force
    // layout has undoubtedly finished its work. Unless something
    // went horribly wrong, you should see two light grey circles
    // connected by a single dark grey line. If you have a screen
    // ruler (such as [xScope](http://xscopeapp.com) handy, measure
    // the distance between the centers of the two circles. It
    // should be somewhere close to the `linkDistance` parameter we
    // set way up in the beginning (480 pixels). That, in the most
    // basic of all nutshells, is what a force layout does. We
    // tell it how far apart we want connected nodes to be, and
    // the layout keeps moving the nodes around until they get
    // reasonably close to that value.

    // Of course, there's quite a bit more than that going on
    // under the hood.

</script>
</body>
</html>